# 시계열 결측치 처리 학습 자료

## Prompts

### Question)
```
시계열 데이터에서 결측치(Missing Values)가 발생하는 원인은 무엇이고, 왜 적절한 처리가 중요한가요?
```

### Answer)
**결측치 발생 원인:**

1. **센서 오류**: 측정 장비 고장, 통신 두절
2. **데이터 수집 문제**: 시스템 다운타임, 저장 실패
3. **비정기적 샘플링**: 불규칙한 측정 주기
4. **휴일/비영업일**: 주식 시장 휴장 등
5. **데이터 정제**: 이상치 제거 후 결측

**적절한 처리가 중요한 이유:**

1. **모델 입력 요구사항**: 대부분의 모델은 완전한 데이터 필요
2. **시간적 연속성**: 시계열의 핵심 특성인 시간 연속성 유지
3. **패턴 왜곡 방지**: 잘못된 처리는 추세/계절성 왜곡
4. **예측 정확도**: 결측치 처리 방식이 성능에 직접 영향

```python
import pandas as pd

# 결측치 확인
print(df.isnull().sum())
print(f"결측 비율: {df.isnull().mean() * 100:.2f}%")

# 결측 패턴 시각화
import missingno as msno
msno.matrix(df)
```

**결측 패턴 유형:**
- **MCAR (Missing Completely at Random)**: 완전 무작위
- **MAR (Missing at Random)**: 다른 변수에 의존
- **MNAR (Missing Not at Random)**: 결측 자체에 패턴

---

### Question)
```
시계열 데이터의 결측치를 채우는 주요 방법들(보간법, Forward Fill 등)을 비교해주세요.
```

### Answer)
**1. Forward Fill (전방 채움)**

이전 유효값으로 채웁니다.

```python
df['value_ffill'] = df['value'].fillna(method='ffill')
# 또는
df['value_ffill'] = df['value'].ffill()
```
- 장점: 간단, 인과성 유지
- 단점: 긴 결측 구간에 부적합

**2. Backward Fill (후방 채움)**

다음 유효값으로 채웁니다.

```python
df['value_bfill'] = df['value'].fillna(method='bfill')
```
- 장점: 간단
- 단점: 미래 정보 사용 (Data Leakage 주의)

**3. 선형 보간 (Linear Interpolation)**

```python
df['value_linear'] = df['value'].interpolate(method='linear')
```
- 장점: 부드러운 전이
- 단점: 비선형 패턴 포착 못함

**4. 다항식/스플라인 보간**

```python
# 스플라인 보간
df['value_spline'] = df['value'].interpolate(method='spline', order=3)

# 다항식 보간
df['value_poly'] = df['value'].interpolate(method='polynomial', order=2)
```
- 장점: 비선형 패턴 포착
- 단점: 양 끝에서 불안정

**5. 시간 기반 보간**

```python
# 시간 인덱스 기반 보간
df['value_time'] = df['value'].interpolate(method='time')
```

**비교:**

| 방법 | 복잡도 | 패턴 보존 | 권장 상황 |
|------|--------|----------|----------|
| Forward Fill | 낮음 | 낮음 | 짧은 결측, 실시간 |
| Linear | 낮음 | 중간 | 부드러운 변화 |
| Spline | 높음 | 높음 | 복잡한 패턴 |
| Time-based | 중간 | 높음 | 불규칙 간격 |

---

### Question)
```
고급 결측치 처리 방법(KNN Imputation, MICE, 딥러닝 기반)에 대해 설명해주세요.
```

### Answer)
**1. KNN Imputation**

유사한 샘플들의 값으로 결측치를 채웁니다.

```python
from sklearn.impute import KNNImputer

imputer = KNNImputer(n_neighbors=5)
df_imputed = pd.DataFrame(
    imputer.fit_transform(df),
    columns=df.columns,
    index=df.index
)
```
- 장점: 다변량 관계 활용
- 단점: 시간 순서 무시 가능

**2. MICE (Multiple Imputation by Chained Equations)**

반복적으로 각 변수를 다른 변수로 예측합니다.

```python
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer

imputer = IterativeImputer(max_iter=10, random_state=42)
df_imputed = pd.DataFrame(
    imputer.fit_transform(df),
    columns=df.columns
)
```
- 장점: 불확실성 추정 가능
- 단점: 계산 비용 높음

**3. 딥러닝 기반 Imputation**

**BRITS (Bidirectional RNN Imputation)**
```python
# 양방향 RNN으로 시간적 패턴 학습
class BRITS(nn.Module):
    def __init__(self, input_dim, hidden_dim):
        super().__init__()
        self.forward_rnn = nn.GRU(input_dim, hidden_dim)
        self.backward_rnn = nn.GRU(input_dim, hidden_dim)
        self.fc = nn.Linear(hidden_dim * 2, input_dim)

    def forward(self, x, mask):
        # mask: 결측 위치 표시
        h_f, _ = self.forward_rnn(x)
        h_b, _ = self.backward_rnn(torch.flip(x, [1]))
        h = torch.cat([h_f, torch.flip(h_b, [1])], dim=-1)
        return self.fc(h)
```

**Transformer 기반:**
```python
# 마스크된 위치 예측 (BERT 스타일)
class TimeSeriesImputer(nn.Module):
    def __init__(self, d_model, nhead, num_layers):
        super().__init__()
        self.transformer = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model, nhead),
            num_layers
        )
        self.fc = nn.Linear(d_model, 1)
```

**방법 선택 가이드:**

| 결측 비율 | 패턴 복잡도 | 권장 방법 |
|----------|-----------|----------|
| < 5% | 단순 | Forward Fill, Linear |
| 5-20% | 중간 | Spline, KNN |
| > 20% | 복잡 | MICE, 딥러닝 |

**실무 팁:**
1. 먼저 결측 패턴 분석
2. 간단한 방법부터 시도
3. 복수의 방법 비교 (민감도 분석)
4. 결측 비율이 너무 높으면 해당 구간 제외 고려
